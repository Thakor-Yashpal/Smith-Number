{"version":3,"sources":["Smith Number.js"],"names":["MAX","primes","sieveSundaram","marked","push","floor","i","LEN","Math","sqrt","j","isSmith","n","original_no","pDigitSum","p","sumDigits","console","log"],"mappings":"aA4BA,IAAIA,IAAM,IAMVC,OAASC,GAIL,SAAAA,gBAUA,IAJIC,IAAAA,EAAOC,KAAPC,MAAAL,IAAA,GAAA,IAGJG,EAAA,GACAG,EAAA,EAAAA,EAAAC,EAAAD,IAJIH,EAAOC,KAAK,GAQX,IAAA,IAAAE,EAAA,EAAAA,GAAAE,KAAAH,OAAAG,KAAAC,KAAAT,KAAA,GAAA,GAAAM,IAGL,IAAA,IAAAI,EAAAJ,GAAAA,EAAA,IAAA,EAAAI,GAAAF,KAAAH,MAAAL,IAAA,GAAAU,EAAAA,EAAA,EAAAJ,EAAA,EAJQH,EAAOO,GAAK,EASpBT,OAASK,KAAC,GAIT,IAAA,IAAAA,EAAA,EAAAA,GAAAE,KAAAH,MAAAL,IAAA,GAAAM,IAGL,GAAAH,EAAAG,IALYL,OAAOG,KAAK,EAAIE,EAAI,GAMhC,SAASK,QAAQC,GAUL,IALR,IAAKC,EAAWZ,EAIRa,EAAA,EACKR,EAAGL,EAAMA,OAAdK,IAAAE,KAAAH,MAAAO,EAAA,GAAAN,IACC,KAAQD,EAAAA,OAALC,IAAJ,GAAA,CAGQE,IAAIO,EAACV,OAAUC,GAE1B,IADIM,EAAAJ,KAAAH,MAAAO,EAAAG,GACJ,EAAAA,GAGLD,GAAAC,EAAA,GACAA,EAAAP,KAAAH,MAAAU,EAAA,IAKK,GAAA,GAAAH,GAAAA,GAAAC,EAGL,KAAA,EAAAD,GACAE,GAAAF,EAAA,GALQA,EAAIJ,KAAKH,MAAMO,EAAI,IAY3B,IAHIC,IAAAA,EAAcL,EAGlB,EAAAK,GACAG,GAAAH,EAAA,GACAA,EAAAL,KAAAH,MAAAQ,EAAA,IAOJ,OAAAC,IAAAE,EAMQd,gBAEIe,QAAAA,IAAQC,qDACX,IAAA,IAAAZ,EAAA,EAAAA,EAAA,IAAAA,IAITK,QAAAL,IALYW,QAAQC,IAAIZ","file":"Smith Number.min.js","sourcesContent":["/*Input  : n = 4\r\nOutput : Yes\r\nPrime factorization = 2, 2  and 2 + 2 = 4\r\nTherefore, 4 is a smith number\r\n\r\nInput  : n = 6\r\nOutput : No\r\nPrime factorization = 2, 3  and 2 + 3 is\r\nnot 6. Therefore, 6 is not a smith number\r\n\r\nInput   : n = 666\r\nOutput  : Yes\r\nPrime factorization = 2, 3, 3, 37 and\r\n2 + 3 + 3 + (3 + 7) = 6 + 6 + 6 = 18\r\nTherefore, 666 is a smith number\r\n\r\nInput   : n = 13\r\nOutput  : No\r\nPrime factorization = 13 and 13 = 13,\r\nBut 13 is not a smith number as it is not\r\na composite number\r\n*/\r\n\r\n\r\n//answer \r\n\r\n// JavaScript program to check whether a number is\r\n// Smith Number or not.\r\nlet MAX = 10000;\r\n\r\n// array to store all prime less than and equal to 10^6\r\nlet primes = [];\r\n\r\n// utility function for sieve of sundaram\r\nfunction sieveSundaram() {\r\n\r\n    // In general Sieve of Sundaram, produces primes smaller\r\n    // than (2*x + 2) for a number given number x. Since\r\n    // we want primes smaller than MAX, we reduce MAX to half\r\n    // This array is used to separate numbers of the form\r\n    // i+j+2ij from others where 1 <= i <= j\r\n    let LEN = Math.floor(MAX / 2) + 100;\r\n    let marked = [];\r\n    for (let i = 0; i < LEN; i++) {\r\n        marked.push(0);\r\n    }\r\n\r\n    // Main logic of Sundaram. Mark all numbers which\r\n    // do not generate prime number by doing 2*i+1\r\n    for (let i = 1; i <= Math.floor((Math.sqrt(MAX) - 1) / 2); i++) {\r\n        for (let j = (i * (i + 1)) << 1; j <= Math.floor(MAX / 2); j = j + 2 * i + 1) {\r\n            marked[j] = 1;\r\n        }\r\n    }\r\n\r\n    // Since 2 is a prime number\r\n    primes.push(2);\r\n\r\n    // Print other primes. Remaining primes are of the\r\n    // form 2*i + 1 such that marked[i] is false.\r\n    for (let i = 1; i <= Math.floor(MAX / 2); i++) {\r\n        if (marked[i] == 0) {\r\n            primes.push(2 * i + 1);\r\n        }\r\n    }\r\n}\r\n\r\n// Returns true if n is a Smith number, else false.\r\nfunction isSmith(n) {\r\n    let original_no = n;\r\n\r\n    // Find sum the digits of prime factors of n\r\n    let pDigitSum = 0;\r\n    for (let i = 0; primes[i] <= Math.floor(n / 2); i++) {\r\n        while (n % primes[i] == 0) {\r\n\r\n            // If primes[i] is a prime factor,\r\n            // add its digits to pDigitSum.\r\n            let p = primes[i];\r\n            n = Math.floor(n / p);\r\n            while (p > 0) {\r\n                pDigitSum += (p % 10);\r\n                p = Math.floor(p / 10);\r\n            }\r\n        }\r\n    }\r\n\r\n    // If n!=1 then one prime factor still to be\r\n    // summed up;\r\n    if (n != 1 && n != original_no) {\r\n        while (n > 0) {\r\n            pDigitSum = pDigitSum + n % 10;\r\n            n = Math.floor(n / 10);\r\n        }\r\n    }\r\n\r\n    // All prime factors digits summed up\r\n    // Now sum the original number digits\r\n    let sumDigits = 0;\r\n    while (original_no > 0) {\r\n        sumDigits = sumDigits + original_no % 10;\r\n        original_no = Math.floor(original_no / 10);\r\n    }\r\n\r\n    // If sum of digits in prime factors and sum\r\n    // of digits in original number are same, then\r\n    // return true. Else return false.\r\n    return (pDigitSum === sumDigits);\r\n}\r\n\r\n// Driver code\r\n\r\n// Finding all prime numbers before limit. These\r\n// numbers are used to find prime factors.\r\n{\r\n    sieveSundaram();\r\n\r\n    console.log(\"Printing first few Smith Numbers using isSmith() \");\r\n    for (let i = 1; i < 500; i++) {\r\n        // console.log(i);\r\n        if (isSmith(i)) {\r\n            console.log(i);\r\n        }\r\n    }\r\n}\r\n\r\n// The code is contributed by Gautam goel (gautamgoel962)"]}